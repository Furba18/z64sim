options {
    DEBUG_TOKEN_MANAGER = false;
    DEBUG_PARSER = false;
    JAVA_UNICODE_ESCAPE = true;
    ERROR_REPORTING = true;
    STATIC = false;
    TOKEN_EXTENDS = "AsmToken";
    COMMON_TOKEN_ACTION = true;
    JDK_VERSION = "1.7";
    BUILD_PARSER = true;
    IGNORE_CASE = true;
}



PARSER_BEGIN(Assembler)
package org.z64sim.assembler;
import java.io.StringReader;
import java.io.Reader;

public class Assembler {

    /**
     * A String-based constructor for ease of use
     */
    public Assembler(String s) {
        this((Reader)(new StringReader(s)));
    }
}
PARSER_END(Assembler)


/*********
 * LEXER *
 *********/

SKIP :
{ " "
| "\t"
| "\r"
| "\n"
}
 
TOKEN:
{ <PROGRAM_BEGIN: ".org">
| <PROGRAM_END: ".end">
| <COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <SCALE: "1" | "2" | "4" | "8">
| <CONSTANT: "$"<NUMBER>>
| <NUMBER: <DEC> | <HEX>>
|   <#DEC: (["0"-"9"])+>
|   <#HEX: "0x"(["0"-"9","a"-"f"])+>
| <REG_8: "%al" | "%cl" | "%dl" | "%bl">
| <REG_16: "%ax" | "%bx" | "%cx" | "%dx" | "%sp" | "%bp" | "%si" | "%di">
| <REG_32: "%eax" | "%ebx" | "%ecx" | "%edx" | "%esp" | "%ebp" | "%esi" | "%edi">
| <REG_64: "%rax" | "%rbx" | "%rcx" | "%rdx" | "%rsp" | "%rbp" | "%rsi" | "%rdi" | "%r8" | "%r9" | "%r10" | "%r11" | "%r12" | "%r13" | "%r14" | "%r15">
| <INSN_0: ( "movs" 
           | "stos" 
           | "in" 
           | "out" 
           | "ins" 
           | "outs")<SUFFIX>>
| <INSN_0_WQ: ("pushf" 
             | "popf" )<SUFFIX_WQ>>
| <INSN_0_NOSUFF:  "ret" 
                 | "iret"
                 | "clc" 
                 | "clp" 
                 | "clz" 
                 | "cls" 
                 | "cli" 
                 | "cld" 
                 | "clo" 
                 | "stc" 
                 | "stp"
                 | "stz" 
                 | "sts" 
                 | "sti"
                 | "std" 
                 | "sto" 
                 | "hlt" 
                 | "nop">
| <INSN_1_S: "int">
| <INSN_1_E: ("push"
           | "pop"
           | "neg"
           | "not")<SUFFIX>>
| <INSN_SHIFT: ("sal"
            | "shl"
            | "sar"
            | "shr"
            | "rcl"
            | "rol"
            | "ror")<SUFFIX>>
| <INSN_1_M: ("jc"
            | "jp"
            | "jz"
            | "js"
            | "jo"
            | "jnc"
            | "jnp"
            | "jnz"
            | "jns"
            | "jno")>
| <INSN_JC: ("jmp"
           | "call")<SUFFIX>>
| <INSN_B_E: ("mov"
            | "add"
            | "sub"
            | "adc"
            | "sbb"
            | "cmp"
            | "test"
            | "and"
            | "or"
            | "xor")<SUFFIX>>
| <INSN_EXT: ("movs" | "movz")<EXT_SUFFIX>>
| <INSN_IN: "in"<SUFFIX>>
| <INSN_OUT: "out"<SUFFIX>>
| <INSN_IO_S: ("ins"
           | "outs")<SUFFIX_BWL>>
| <LABEL: <STRING>":">
| <STRING: ([".","_","-"]|["a"-"z"]|["0"-"9"])+ >
| <LBRACE: "(">
| <RBRACE: ")">
| <#SUFFIX: "b" | "w" | "l" | "q">
| <#SUFFIX_BWL: "b" | "w" | "l" | "q">
| <#SUFFIX_WQ: "w" | "q">
| <#EXT_SUFFIX: "bw" | "bl" | "bq" | "wl" | "wq" | "lq">
}


/****************
 * PARSER RULES *
 ****************/


void Program() :
{}
{<PROGRAM_BEGIN>
 ( Label() | Instruction() )+
 <PROGRAM_END>
 <EOF>
}


void Instruction() :
{}
{
   <INSN_0>
 | <INSN_0_WQ>
 | <INSN_0_NOSUFF>
 | <INSN_1_S> <NUMBER>
 | <INSN_1_E> FormatE()
 | <INSN_SHIFT> ( FormatK() "," )? FormatG()
 | <INSN_1_M> FormatM()
 | <INSN_JC> ( FormatM() | "*" FormatG() )
 | <INSN_B_E> FormatB() "," FormatE()
 | <INSN_EXT> FormatE() "," FormatG()
 | <INSN_IN> <REG_16> "," (<REG_8> | <REG_16> | <REG_32> | <REG_64>) /* programmatically check for registers */
 | <INSN_OUT> (<REG_8> | <REG_16> | <REG_32> | <REG_64>) "," <REG_16> /* programmatically check for registers */
 | <INSN_IO_S>
}

void Label() :
{}
{ <LABEL> }


void Register() :
{}
{ <REG_8> | <REG_16> | <REG_32> | <REG_64> }


void Addressing() :
{}
{ 
  ( <CONSTANT> /* | <LABEL> */ )?
  ( <LBRACE>
   (<REG_8> | <REG_16> | <REG_32> | <REG_64>)
   "," 
   (<REG_8> | <REG_16> | <REG_32> | <REG_64>) "," <SCALE>
  <RBRACE> )?
}


void FormatE() :
{}
{ (Register() | <CONSTANT> | Addressing())}

void FormatK() :
{}
{ "/" }

void FormatG() :
{}
{ "/" }


/* Both label and direct address */
void FormatM() : 
{}
{ "/" }

void FormatB() :
{}
{ "/" }


TOKEN_MGR_DECLS:
{
    void CommonTokenAction(Token t) {
        AsmToken tok = (AsmToken)t;
        tok.start = input_stream.nextCharInd - t.image.length();
        tok.length = t.image.length();
        tok.token = t;

        System.out.println("Token " + tok.token.image + " (" + tok.token.kind + ") from " + tok.start + " len " + tok.length);
    }
}